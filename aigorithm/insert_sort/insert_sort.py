import random
from aigorithm.timewrap import cal_time

"""
思路:随便选取一张牌和前面一张牌(选择的牌前面必须有牌)的数字进行比较,如果比它小就将继续向前比较,
知道前边不再有牌,或者数字大于了这张牌,不再有牌就插在最前方,小于前边的牌,就插在那张牌后边
插入排序的实现:每次从无序区选择一个元素插入到有序区
---- 有序区 ---- | ---- 无序区 ---- 
8               |   3 6 4 1 2 9 5
8               |   3
3 8             |
3 8             |     6
3 6 8           |       4
3 4 6 8         |
             ...
1 2 3 4 5 6 8 9 |                        
"""


# 插入排序 时间复杂度o(n^2)
@cal_time
def insert_sort(li):
    for i in range(1, len(li)):
        # 选取无序区第一个元素(每次循环有序区多一个,无序区少一个,所以可以每次选取的都是无序区第一个元素)
        j = i - 1  # 前边紧挨着的有序区最大的数(即此时进行比较的前一张牌)
        tmp = li[i]
        while j >= 0 and li[j] > tmp:
            # 终止条件: 当与有序区比较时小于所有有序区的数即j<0时,当数字大于有序区某个数即li[j]>tmp时
            li[j + 1] = li[j]  # 有序区的牌向后挪动,继续与前边的牌比较
            j = j - 1
        # 1. 此时j=-1,前边已经没有牌,将此牌放在有序区第一位,索引j+1=0
        # 2. 此时此牌大于有序区第j张牌,将此牌插在j+1上
        li[j + 1] = tmp


li = list(range(10000))
random.shuffle(li)
insert_sort(li)